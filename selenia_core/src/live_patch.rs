//! Live-Patch engine â€“ apply binary diff without stopping the process.
//!
//! Given an ELF text segment diff produced offline, this module mmaps the patch
//! file with `PROT_READ` and then performs an in-place `mprotect` dance to mark
//! the affected pages writable, copies the diff, flushes ICACHE, and restores
//! `PROT_EXEC|PROT_READ`. All operations are done per-page to keep race window
//! minimal.
//!
//! WARNING: Callers must ensure the patch is verified and compatible with the
//! current binary. This engine only applies the diff; it does not handle
//! version checks or rollback on failure.

#[cfg(target_os = "linux")]
use std::os::unix::io::AsRawFd;
use std::fs::File;
use std::io::{self, Read};

#[cfg(target_os = "linux")]
use libc::{c_void, mprotect, sysconf, _SC_PAGESIZE, PROT_EXEC, PROT_READ, PROT_WRITE};

/// Apply an in-memory ELF patch generated by `bspatch`-like tool.
/// `patch_path` points to a binary diff format: list of (offset,u32 len, bytes).
pub fn apply_patch(patch_path: &str) -> io::Result<()> {
    #[cfg(not(target_os = "linux"))]
    { return Err(io::Error::new(io::ErrorKind::Unsupported, "live patch unsupported")); }

    #[cfg(target_os = "linux")]
    {
        let mut f = File::open(patch_path)?;
        let mut buf = Vec::new();
        f.read_to_end(&mut buf)?;
        let mut idx = 0;
        unsafe {
            let page = sysconf(_SC_PAGESIZE) as usize;
            while idx + 12 <= buf.len() {
                let offs = u64::from_le_bytes(buf[idx..idx+8].try_into().unwrap()) as usize;
                let len = u32::from_le_bytes(buf[idx+8..idx+12].try_into().unwrap()) as usize;
                idx += 12;
                if idx + len > buf.len() { return Err(io::Error::new(io::ErrorKind::InvalidData, "patch truncated")); }
                let src_ptr = buf[idx..idx+len].as_ptr();
                let dst_ptr = (offs as *mut c_void) as *mut u8;
                // Align page
                let page_base = (dst_ptr as usize) & !(page - 1);
                let res1 = mprotect(page_base as *mut c_void, ((len + (dst_ptr as usize - page_base) + page -1)/page)*page, PROT_READ|PROT_WRITE);
                if res1 != 0 { return Err(io::Error::last_os_error()); }
                std::ptr::copy_nonoverlapping(src_ptr, dst_ptr, len);
                let _ = mprotect(page_base as *mut c_void, ((len + (dst_ptr as usize - page_base) + page -1)/page)*page, PROT_READ|PROT_EXEC);
                idx += len;
            }
            // Flush instruction cache
            #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
            core::arch::x86_64::_mm_mfence();
        }
        Ok(())
    }
} 